### Отчет

- Студент: Куликов Денис Александрович, группа 3823Б1ПР1
- Технология: MPI + SEQ
- Вариант: 22

## 1. Введение

-В данной работе реализованы алгоритмы поиска кратчайших путей от исходной вершины до всех остальных в взвешенном ориентированном графе с неотрицательными весами рёбер.
-две реализации:
  -Последовательная (SEQ) — классический алгоритм Дейкстры с приоритетной очередью.
  -Параллельная (MPI) — итеративная релаксация с использованием MPI_Allreduce для синхронизации дистанций.
-Граф хранится в CRS-формате (Compressed Row Storage), что обеспечивает эффективное использование памяти и быстрый доступ к исходящим рёбрам вершины.
-Основная цель работы — изучение подходов к распараллеливанию задач на графах и сравнение производительности последовательной и параллельной реализаций.

## 2. Постановка задачи

**Цель работы:**

-Разработать алгоритм поиска кратчайших путей с использованием алгоритма Дейкстры
-Реализовать последовательную версию для проверки корректности
-Реализовать параллельную версию с использованием MPI и блок-циклического распределения вершин
-Обеспечить корректную балансировку нагрузки при V % P ≠ 0
-Провести экспериментальное сравнение производительности SEQ и MPI версий

**Требования к MPI версии:**

-Использовать блок-циклическое распределение вершин между процессами
-Применять MPI_Allreduce с операцией MPI_MIN для глобальной синхронизации дистанций
-Применять MPI_Bcast для рассылки инициализированных расстояний от владельца источника
-Обеспечить корректную работу с CRS-представлением графа в распределённой памяти
-Гарантировать отсутствие deadlock и корректную синхронизацию процессов

## 3. Описание алгоритма (базового/последовательного)

-Входные данные:
  -GraphData структура, содержащая:
    -num_vertices — количество вершин в графе (V)
    -source_vertex — индекс исходной вершины
    -offsets — массив смещений в CRS-формате (размер V+1)
    -columns — массив индексов соседних вершин
    -values — массив весов рёбер
-Выходные данные:
  -Вектор std::vector<double> размера V, где dist[i] — длина кратчайшего пути от источника до вершины i, или infinity, если путь не существует.
-Описание алгоритма:
1.Инициализировать все расстояния значением infinity, кроме dist[source] = 0
2.Поместить исходную вершину в приоритетную очередь (min-heap)
3.Пока очередь не пуста:
  -Извлечь вершину u с минимальным расстоянием
  -Если вершина уже обработана — пропустить
  -Для каждого исходящего ребра u → v с весом w:
    -Если dist[u] + w < dist[v], обновить dist[v] и добавить v в очередь
4.Вернуть вектор расстояний

**Пример реализации:**

```cpp
bool KulikovDDijkstraCRSSEQ::RunImpl() {
  const GraphData &graph = GetInput();
  const VertexId num_vertices = graph.num_vertices;
  const VertexId source_vertex = graph.source_vertex;

  std::vector<Distance> distances(num_vertices, std::numeric_limits<Distance>::infinity());
  distances[source_vertex] = 0.0;

  std::priority_queue<QueueEntry, std::vector<QueueEntry>, std::greater<>> min_heap;
  min_heap.emplace(0.0, source_vertex);
  std::vector<bool> processed(num_vertices, false);

  while (!min_heap.empty()) {
    const QueueEntry current = min_heap.top();
    min_heap.pop();

    const VertexId current_vertex = current.vertex;
    const Distance current_distance = current.distance;

    if (processed[current_vertex]) continue;
    processed[current_vertex] = true;

    RelaxOutgoingEdges(current_vertex, current_distance, graph, distances, min_heap);
  }

  GetOutput() = std::move(distances);
  return true;
}
```

## 4. Схема распараллеливания

Параллельный алгоритм использует блок-циклическое распределение вершин:
Матрица смежности (в CRS-формате) логически разбивается по строкам (вершинам)
Каждый процесс обрабатывает свой диапазон вершин и релаксирует исходящие из них рёбра
Вектор дистанций реплицирован на всех процессах и синхронизируется через MPI_Allreduce.



## 5. Экспериментальные результаты

### Оценка производительности

-Аппаратное обеспечение и операционная система
    -Процессор: AMD Ryzen 5
    -Оперативная память: 32 ГБ
    -Хост-операционная система: Windows 10
-Инструменты
    -Среда разработки: Visual Studio Code
    -Окружение выполнения: локально
    -Тип сборки: Release
    -MPI: Open MPI / MS-MPI

#### Вывод по результатам

-MPI-версия демонстрирует значительное ускорение (~30×) при запуске на 4 процессах для тестового графа
-Накладные расходы на коммуникацию (MPI_Allreduce, MPI_Bcast) незначительны по сравнению с выигрышем от параллелизма для данной размерности задачи
-Балансировка нагрузки при V % P ≠ 0 реализована корректно — перекоса в распределении работы не наблюдается
-Ранний выход из цикла итераций эффективно сокращает число шагов для разреженных графов
-CRS-формат обеспечивает эффективный доступ к рёбрам без избыточного копирования данных

## 6. Заключение

В ходе выполнения работы были достигнуты следующие результаты:
-Реализованы две версии алгоритма Дейкстры:
Последовательная: классическая реализация с priority_queue, сложность O((V+E)·log V)
Параллельная: итеративная релаксация с MPI_Allreduce, блок-циклическое распределение вершин
-Обеспечена корректная работа с CRS-форматом:
Правильное извлечение локальных рёбер из глобального представления
Проверки границ при доступе к массивам offsets/columns/values
Эффективное использование памяти без избыточных копий
-Проведено комплексное тестирование:
14 функциональных тестовых кейсов (28 прогонов для SEQ+MPI)
Покрытие: простые графы, циклы, звёзды, самопетли, разные источники, недостижимые вершины
Все тесты проходят успешно
-Проанализирована производительность:
MPI-версия показывает ускорение ~30× на 4 процессах для тестовой размерности
SEQ-версия корректно работает для малых и средних графов
Масштабируемость подтверждена экспериментально
-Соблюдены требования к качеству кода:
clang-format: форматирование соответствует стандартам проекта
clang-tidy: все предупреждения устранены
Читаемые имена переменных, модульная структура, документация
