# Подсчёт количества смен знаков в векторе

- Студент: Иманов Сабутай Ширзад оглы
- Группа: 3823Б1ПР5
- Технология: SEQ | MPI
- Вариант: 5

## 1. Введение

Обработка числовых последовательностей с анализом изменения знаков является важной операцией в
цифровой обработке сигналов и анализе данных. Подсчёт точек, где знак значения меняется (например,
переход от положительного к отрицательному или наоборот), используется в приложениях обнаружения
границ, анализе временных рядов и обработке звука.

**Цель работы:** реализовать алгоритм подсчёта смен знаков в векторе в двух вариантах —
последовательный (SEQ) и параллельный с использованием MPI (Message Passing Interface), провести
сравнение производительности и оценить эффективность параллелизации с разным числом процессов.

## 2. Постановка задачи

**Входные данные:** целое число n ≥ 0, которое определяет размер виртуального вектора.

**Выходные данные:** целое число — количество смен знаков в векторе (переходов между
положительными и отрицательными значениями, исключая нули).

**Алгоритм:** элементы вектора генерируются по функции:

- GetElement(i) = 0.0, если i % 5 == 0
- GetElement(i) = 1.0, если i % 2 == 0
- GetElement(i) = -1.0, в остальных случаях

**Функция Sign:** преобразует значение в -1, 0 или 1:

- Sign(x) = 1, если x > 0
- Sign(x) = -1, если x < 0
- Sign(x) = 0, если x == 0

**Логика подсчёта:** для каждого элемента игнорируем нули и считаем переход от одного ненулевого
знака к другому как одно событие смены знака.

**Ограничения:**

- n может быть от 0 до очень больших значений
- Нулевые элементы пропускаются (не считаются за смену)
- Результат всегда неотрицательное целое число

## 3. Базовый алгоритм (Последовательный)

Последовательная реализация выполняет следующие шаги:

```text
1. Если n <= 0:
   return 0

2. Инициализировать:
   prev = 0      // предыдущий ненулевой знак
   cnt = 0       // счётчик смен знака

3. Для каждого индекса i от 0 до n-1:
   a) Получить элемент: val = GetElement(i)
   b) Вычислить знак: s = Sign(val)
   c) Если s == 0:
      continue (пропустить нули)
   d) Если prev != 0 И s != prev:
      cnt++    (найдена смена знака)
   e) prev = s

4. Вернуть cnt
```

**Временная сложность:** O(n) — один проход по всем элементам.
**Пространственная сложность:** O(1) — только несколько переменных.

## 4. Схема параллелизации (MPI)

В параллельной реализации с MPI используется распределённый подход:

### 4.1 Распределение данных

- Вектор логически разделяется между p процессами неравномерно
- Процесс ранга r получает элементы с индексами от begin[r] до end[r]
- Распределение учитывает остаток: первые rem процессов получают по (base + 1) элементов

### 4.2 Локальная обработка

Каждый процесс независимо:

- Обрабатывает свой фрагмент вектора с помощью ProcessSegment
- Вычисляет локальное количество смен (count)
- Запоминает первый ненулевой знак (first_sign)
- Запоминает последний ненулевой знак (last_sign)

Особенность: может случиться, что в конце фрагмента одного процесса и в начале фрагмента
следующего произойдёт смена знака — это учитывается на этапе глобальной комбинации.

### 4.3 Глобальная комбинация

```text
1. Каждый процесс отправляет три значения (count, first_sign, last_sign) на процесс 0
2. Процесс 0 выполняет MPI_Gather для получения информации от всех процессов
3. Процесс 0 вызывает CombineGlobal:
   - Проходит по результатам всех процессов
   - Проверяет смены знака между соседними фрагментами
   - Суммирует локальные смены и смены между фрагментами
```

**Коммуникационная схема:** одна операция MPI_Gather, минимальные накладные расходы.

## 5. Детали реализации

### 5.1 Структура кода

```text
sabutay_vector_sign_changes/
├── seq/
│   ├── include/
│   │   └── ops_seq.hpp
│   └── src/
│       └── ops_seq.cpp
├── mpi/
│   ├── include/
│   │   └── ops_mpi.hpp
│   └── src/
│       └── ops_mpi.cpp
└── common/
    └── include/
        └── common.hpp
```

### 5.2 Ключевые классы и функции

**Последовательная версия:**

- `SabutayVectorSignChangesSEQ` — основной класс, наследует `BaseTask`
- `RunImpl()` — главный метод, выполняющий подсчёт смен знаков
- `Sign(double x)` — преобразование значения в знак
- `GetElement(size_t i)` — генерация элемента вектора

**Параллельная версия (MPI):**

- `SabutayVectorSignChangesMPI` — основной класс для MPI
- `ProcessSegment()` — обработка локального фрагмента вектора
- `ComputeRange()` — вычисление границ фрагмента для процесса
- `CombineGlobal()` — объединение результатов от всех процессов
- `LocalInfo` — структура с локальной информацией (count, first_sign, last_sign)

**Общие типы (common.hpp):**

```cpp
using InType = double;   // размер вектора n
using OutType = int;     // количество смен знаков
using BaseTask = ppc::task::Task<InType, OutType>;
```

### 5.3 Важные предположения и граничные случаи

- **n = 0:** возвращается 0 (пустой вектор)
- **n = 1:** возвращается 0 (нет смены с одним элементом)
- **Все нули:** возвращается 0 (нет ненулевых элементов для сравнения)
- **Один ненулевой знак:** возвращается 0 (смены не происходят)
- **Чередующиеся знаки:** максимальное количество смен

### 5.4 Использование памяти

- **Последовательная версия:** O(1) дополнительной памяти
- **MPI версия:** O(p) памяти на процессе 0 для сбора данных от p процессов
- Генерация элементов на лету — без хранения всего вектора в памяти

## 6. Экспериментальная установка

### 6.1 Аппаратное обеспечение и ОС

- **Компьютер:** XIAOMI Redmi Book Pro 16 2024
- **Процессор:** Intel Core (Model 170), ~1200 МГц
- **Ядра/потоки:** 1 процессор (логических ядер ≤ 8)
- **Оперативная память:** 32 221 МБ (~32 ГБ)
- **ОС:** Microsoft Windows 11 Pro (build 26200)
- **Архитектура:** x64-based PC

### 6.2 Инструментарий

- **Компилятор:** Microsoft Visual C++ (MSVC)
- **Тип сборки:** Release (оптимизированная)
- **Build system:** CMake 3.x
- **MPI реализация:** Microsoft MPI или Intel MPI
- **Стандарт C++:** C++20
- **Framework тестирования:** Google Test

### 6.3 Окружение

- **PPC_NUM_THREADS:** N/A (процессная модель)
- **PPC_NUM_PROC:** 2, 4, 6 (для MPI тестов)
- **Режимы запуска:**
  - SEQ функциональные: `./ppc_func_tests.exe --gtest_filter="*vector*"`
  - MPI функциональные (4 проц.): `mpiexec -n 4 ./ppc_func_tests.exe`
  - SEQ производительность: `./ppc_perf_tests.exe`
  - MPI производительность: `mpiexec -n N ./ppc_perf_tests.exe`

### 6.4 Тестовые данные

Тесты используют различные размеры вектора:

- **n=0:** пустой вектор (граничный случай)
- **n=1:** одноэлементный вектор
- **n=5:** малый вектор
- **n=10:** средний вектор
- **n=25:** большой вектор

Производительность тестируется на размерах порядка n = 10⁶—10⁷.

## 7. Результаты и обсуждение

### 7.1 Корректность

**Функциональные тесты (Google Test):**

Запуск последовательной версии (**без MPI**):

```text
./ppc_func_tests.exe --gtest_filter="*sabutay*vector*"
[  PASSED  ] 5 tests.        (SEQ версия)
[  SKIPPED ] 5 tests.        (MPI как ожидается)
```

Запуск с MPI (**mpiexec -n 4**):

```text
mpiexec -n 4 ./ppc_func_tests.exe --gtest_filter="*sabutay*vector*"
[  PASSED  ] 10 tests.       (SEQ + MPI все прошли)
```

**Результат:** обе версии корректны. Все 5 функциональных тестов для каждого режима пройдены
успешно:

- n=0, n=1, n=5, n=10, n=25

Алгоритм правильно обрабатывает граничные случаи и корректно учитывает нулевые элементы и
переходы между фрагментами в MPI версии.

### 7.2 Производительность

| Конфигурация | Режим | Время (сек) | Ускорение | Эффективность |
| --- | --- | --- | --- | --- |
| SEQ (1 проц.) | pipeline | 0.008337 | 1.00 | 100% |
| SEQ (1 проц.) | task_run | 0.006883 | 1.00 | 100% |
| MPI (2 проц.) | pipeline | 0.004059 | 2.05 | 102.5% |
| MPI (2 проц.) | task_run | 0.003815 | 1.80 | 90.0% |
| MPI (4 проц.) | pipeline | 0.002375 | 3.51 | 87.8% |
| MPI (4 проц.) | task_run | 0.003288 | 2.09 | 52.3% |
| MPI (6 проц.) | pipeline | 0.002233 | 3.73 | 62.2% |
| MPI (6 проц.) | task_run | 0.002856 | 2.41 | 40.1% |

**Расчёт ускорения и эффективности:**

- Ускорение = Время_SEQ / Время_MPI
- Эффективность = Ускорение / Число_процессов × 100%

### 7.3 Анализ результатов

**Наблюдения:**

1. **Pipeline режим превосходит task_run для MPI:**
   - Pipeline MPI 4 проц.: 3.51x ускорение, 87.8% эффективность
   - Task_run MPI 4 проц.: 2.09x ускорение, 52.3% эффективность
   - Это указывает на то, что полный конвейер (PreProcessing → Run → PostProcessing) работает
     лучше, чем только Run с отдельно выполняемыми шагами

2. **Масштабируемость с MPI:**
   - 2 процесса: 2.05x ускорение (почти линейное)
   - 4 процесса: 3.51x ускорение (хорошая масштабируемость)
   - 6 процессов: 3.73x ускорение (улучшение замедляется)
   - Причина: стоимость MPI_Gather начинает доминировать при увеличении числа процессов

3. **Эффективность использования процессов:**
   - Pipeline режим показывает хорошую эффективность до 4 процессов
   - Task_run режим менее эффективен из-за накладных расходов на синхронизацию

4. **Сравнение SEQ и MPI:**
   - Даже с одним процессом (MPI 1) MPI версия медленнее из-за коммуникационных операций
   - С 4+ процессами параллельное ускорение компенсирует эти расходы

**Узкие места:**

1. **MPI_Gather:** операция сбора данных на процессе 0 становится узким местом при p > 4
2. **Генерация элементов:** каждый процесс генерирует свои элементы (нет передачи данных)
3. **Малый объём локальных данных:** при большом p каждый процесс обрабатывает всё меньше
   элементов, и накладные расходы MPI становятся значительнее

## 8. Выводы

1. **Правильность:** обе реализации (SEQ и MPI) корректны и проходят все функциональные тесты с
   различными размерами входных данных.

2. **Параллелизм показывает хорошие результаты:** реализация MPI с 4 процессами достигает
   ускорения **3.51x** в pipeline режиме, что хорошо для простого алгоритма с минимальной
   коммуникацией.

3. **Оптимальное число процессов:** для данной задачи эффективно порядка 4 процессов; дальнейшее
   увеличение приводит к снижению эффективности из-за накладных расходов MPI.

4. **Pipeline режим предпочтителен:** для MPI реализации pipeline режим показывает лучшую
   производительность, чем task_run, на всех числах процессов.

5. **Применимость:**
   - SEQ версия: для небольших n (< 10⁶) или систем без поддержки MPI
   - MPI версия: для больших n (> 10⁶) с 2–4 процессами для оптимальной производительности

6. **Масштабируемость:** алгоритм хорошо масштабируется до 4 процессов, где MPI оверхеды
   компенсируются параллельной обработкой.

## 9. Использованные источники и ссылки

1. **MPI Standard:** <https://www.mpi-forum.org/>
2. **Open MPI Documentation:** <https://www.open-mpi.org/doc/>
3. **C++ Standard Library:** <https://en.cppreference.com/w/cpp/>
4. **Google Test Framework:** <https://google.github.io/googletest/>
5. **Signal Processing Algorithms:** Oppenheim & Schafer, "Discrete-Time Signal Processing"

## Приложение (Дополнительный код)

### A1. Функция подсчёта знака

```cpp
inline int Sign(double x) {
  if (x > 0.0) {
    return 1;
  }
  if (x < 0.0) {
    return -1;
  }
  return 0;
}
```

### A2. Генерация элементов вектора

```cpp
inline double GetElement(std::size_t i) {
  if (i % 5 == 0) {
    return 0.0;
  }
  if (i % 2 == 0) {
    return 1.0;
  }
  return -1.0;
}
```

### A3. Локальная обработка в MPI

```cpp
struct LocalInfo {
  int count{};       // количество смен в локальном фрагменте
  int first_sign{};  // первый ненулевой знак
  int last_sign{};   // последний ненулевой знак
};

inline LocalInfo ProcessSegment(std::size_t begin, std::size_t end) {
  LocalInfo info{};

  for (std::size_t i = begin; i < end; ++i) {
    const int s = Sign(GetElement(i));
    if (s == 0) {
      continue;  // пропускаем нули
    }

    if (info.first_sign == 0) {
      info.first_sign = s;  // запомнить первый ненулевой знак
    }
    if (info.last_sign != 0 && info.last_sign != s) {
      ++info.count;  // найдена смена знака
    }
    info.last_sign = s;
  }

  return info;
}
```

### A4. Глобальная комбинация результатов

```cpp
inline int CombineGlobal(const std::vector<int> &all_info) {
  int global_count = 0;
  int prev_sign = 0;
  const std::size_t size = all_info.size() / 3;

  for (std::size_t proc = 0; proc < size; ++proc) {
    const int lc = all_info[(3 * proc) + 0];  // локальный счётчик
    const int fs = all_info[(3 * proc) + 1];  // первый знак
    const int ls = all_info[(3 * proc) + 2];  // последний знак

    if (fs != 0) {
      // проверить смену между соседними фрагментами
      if (prev_sign != 0 && fs != prev_sign) {
        ++global_count;
      }
      if (ls != 0) {
        prev_sign = ls;  // обновить для следующего фрагмента
      }
    }

    global_count += lc;  // добавить локальные смены
  }

  return global_count;
}

